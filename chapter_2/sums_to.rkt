#lang racket

(define (check S p r x cc)
  (let ((len (- r p)))
    (if (> len 2)
        (let ((q (+ p (floor (/ len 2)))))
          (check S p q x cc)
          (check S q r x cc)
          (merge S p q r x cc))
        (if (= len 2)
            (let ((a (vector-ref S p)) (b (vector-ref S (- r 1))))
              (if (= x (+ a b))
                  (cc (list a b))
                  '()))
            '()))))

(define (merge S p q r x cc)
  (let ((len (- r p)) (left-len (- q p)) (right-len (- r q))
        (left (sub-vector S p q)) (right (sub-vector S q r)))
    (let loop ((i 0) (j 0) (k 0))
      (if (< k len)
          (if (< i left-len)
            (let ((a (vector-ref left i)))
              (if (< j right-len)
                (let ((b (vector-ref right j)))
                  (if (= x (+ a b))
                      (cc (list a b))
                      (if (< a b)
                          (begin
                            (vector-set! S (+ p k) a)
                            (loop (+ i 1) j (+ k 1)))
                          (begin
                            (vector-set! S (+ p k) b)
                            (loop i (+ j 1) (+ k 1))))))
                (begin
                  (vector-set! S (+ p k) a)
                  (loop (+ i 1) j (+ k 1)))))
            (if (< j right-len)
              (let ((b (vector-ref right j)))
                (begin
                  (vector-set! S (+ p k) b)
                  (loop i (+ j 1) (+ k 1))))
              '()))
          '()))))

(define (sub-vector vec i j)
  (let ((x (make-vector (- j i))))
    (let loop ((k 0))
      (if (< k (- j i))
          (begin
            (vector-set! x k (vector-ref vec (+ i k)))
            (loop (+ k 1)))
          x))))
    
(define (sums-to S x)
  (let ((q (floor (/ (vector-length S) 2))) (n (vector-length S)))
    (call/cc (lambda (cc)
      (check S 0 q x cc)
      (check S q n x cc)
      (merge S 0 q n x cc)))))